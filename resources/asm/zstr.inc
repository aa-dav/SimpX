; ZSTR - функции по работе с ASCIIZ-строками (как в Си)

; Важно заметить, что все функции в отличие от сишного stdlib возвращают
; указатель не на начало, а на конец строки - так код становится намного гибче.

; *** ПЕРЕМЕННЫЕ ***
; hexNumbers	- массив 16-ричных цифр 023456789ABCDEF

; *** ПРОЦЕДУРЫ *** 
; zstrPrint	- печать строки
; zstrLength	- получить длину и конец строки
; zstrCopy	- скопировать строку в буфер
; zstrFromHex	- сконвертировать число в строку (16-ричное представление)
; zstrFromNum	- сконвертировать беззнаковое число в строку
; zstrFromInt	- сконвертировать число со знаком в строку

; zstrPrint - напечатать строку терминирующуюся нулём
; in: r0 - указатель на строку				  
zstrPrint		[ sp ] <- r0	; сохраним регистры в стек
		[ sp ] <- r1
		r1 <- r0		; переложим указатель на строку в r1
.loop		r0 <= [ r1 ]	; копируем в r0 символ по адресу r1 обновляя флаги
		jz .end		; если он оказался нулевым - выходим
		call printSpChar	; печатаем символ в r0
		r1 <- r1 + 1	; увеличиваем указатель
		pc <- .loop	; зацикливаемся
.end		r1 <- [ sp ]	; восстанавливаем регистры из стека
		r0 <- [ sp ]
		ret		; выходим из процедуры
		
; zstrLength - длина ASCIIZ-строки
; вход:	r0 - указатель на начало строки
; выход:	r0 - указатель на конец строки (символ 0)
;	r1 - длина строки
zstrLength	r1 = r1 - r1	; обнуляем r1
.loop		void <= [ r0 ]	; тестируем символ по адресу r0
		jz .end		; если он нулевой - выходим
		r0 <- r0 + 1	; увеличиваем r0
		r1 <- r1 + 1	; увеличиваем r1
		pc <- .loop	; зацикливаемся
.end		ret		; выходим из процедуры

; zstrCopy - скопировать ASCIIZ-строку в буфер
; вход:	r0 - указатель куда копируем
;	r1 - указатель откуда копируем
; выход:	r0 - конец буфера куда копировали (символ 0)
zstrCopy		[ sp ] <- r1	; сохраняем r1 в стек
.loop		[ r0 ] <= [ r1 ]	; копируем из адреса r1 в адрес r0 с обновлением флагов
		jz .end		; если был скопирован ноль - идём на выход
		r0 <- r0 + 1	; увеличиваем r0
		r1 <- r1 + 1	; увеличиваем r1
		pc <- .loop	; зацикливаемся
.end		r1 <- [ sp ]	; восстанавливаем r1 из стека
		ret		; выходим из процедуры

hexNumbers	dw "0123456789ABCDEF"	; массив 16-ричных цифр

; zstrFromHex - конвертировать беззнаковое число в ASCIIZ-строку 16-ричного представления
; вход:	r0 - указатель на буфер строки
;	r1 - число
; выход:	r0 - конец буфера строки
zstrFromHex	[ sp ] <- r1	; сохраняем регистры в стек
		[ sp ] <- r2

		r1 <= r1 >> 12	; прокручиваем r1 на 12 бит - верхние 4 бита станут нижними
		r2 = r1 & $000F	; записываем в r2 нижние 4 бита r1
		r2 = hexNumbers + r2	; r2 - адрес с 16-ричной цифрой
		[ r0 ] <- [ r2 ]	; копируем в адрес r0 символ цифры из адреса r2
		r0 <- r0 + 1	; увеличиваем указатель на буфер строки

		r1 <= r1 >> 12	; повторяем действия выше еще три раза...
		r2 = r1 & $000F
		r2 = hexNumbers + r2
		[ r0 ] <- [ r2 ]
		r0 <- r0 + 1

		r1 <= r1 >> 12	; ...для каждой из...
		r2 = r1 & $000F
		r2 = hexNumbers + r2
		[ r0 ] <- [ r2 ]
		r0 <- r0 + 1

		r1 <= r1 >> 12	; ...четырёх цифр
		r2 = r1 & $000F
		r2 = hexNumbers + r2
		[ r0 ] <- [ r2 ]
		r0 <- r0 + 1
		
		[ r0 ] <- 0	; записываем в конец буфера 0

		r2 <- [ sp ]	; восстанавливаем регистры из стека
		r1 <- [ sp ]
		ret		; выходим из процедуры

; zstrFromNum - конвертировать беззнаковое число в ASCIIZ-строку
; вход:	r0 - указатель на буфер строки
;	r1 - число
; выход:	r0 - конец буфера строки
zstrFromNum	r1 <= r1		; тестируем число в r1 на ноль
		jnz .full		; если не ноль - идём на полный алгоритм
		[ r0 ] <- '0'	; иначе сразу записываем в буфер цифру '0'
		r0 <- r0 + 1	; увеличиваем указатель на буфер
		[ r0 ] <- 0	; записываем 0 (конец строки)
		ret		; и выходим из процедуры
		; используется алгоритм поледовательно вычитающий из числа
		; степени десятки пока не получится <= 0 и подсчитывающий
		; число необходимых шагов для этого - это число и есть цифра
		; в данном разряде. для всего этого нужна таблица степеней десятки:
.decPowers	dw 10000 1000 100 10 1 0
.full		[ sp ] <- r1	; сохраняем регистры в стек
		[ sp ] <- r2
		[ sp ] <- r3
		r3 <- .decPowers	; в r3 - указатель на буфер степеней десятки
		; прямолинейная реализация вышеописанного алгоритма будет писать
		; лидирующие нули, что нам не нужно.
		; поэтому мы разобъём алгоритм на две части - первая (где метки
		; кончаются нулём) не записывает числа (нули) в буфер, но как
		; только обнаруживает, что получается не нулевая цифра, то
		; переходит в то же самое место второй части которая уже 
		; записывает цифры в буфер.
.next_digit0	[ r0 ] <- '0'	; записываем в буфер символ нуля
		r2 <= [ r3 ]	; в r2 считываем текущую степень десятки
		jz .end		; если она ноль - значит мы закончили
		r3 <- r3 + 1	; указатель на степени десятки увеличиваем
		
.loop0		r1 = r1 - r2	; вычитаем из числа текущую степень десятки
		jc .next0		; если сразу переполнение - значит 0 и нам
				; сейчас надо перейти к следующему разряду
		pc <- .not_zero	; иначе текущая цифра не 0 - идём в полный алгоритм
.next0		r1 = r1 + r2	; восстановим в r1 число до переполнения
		pc <- .next_digit0	; переходим к следующей итерации
		
		; далее идёт "активная" форма алгоритма записывающая цифры в буфер
.next_digit	[ r0 ] <- '0'	; записываем в буфер символ нуля
		r2 <= [ r3 ]	; в r2 считываем текущую степень десятки
		jz .end		; если она ноль - значит мы закончили
		r3 <- r3 + 1	; указатель на степени десятки увеличиваем		
		
.loop		r1 = r1 - r2	; вычитаем из числа текущую степень десятк
		jc .next		; если переполнение - переходим к следующему разряду
.not_zero		[ r0 ] <- [ r0 ] + 1	; увеличиваем цифру в буфере
		pc <- .loop	; зацикливаемся
.next		r1 = r1 + r2	; восстановим в r1 число до переполнения
		r0 <- r0 + 1	; увеличим указатель на буфер
		pc <- .next_digit	; переходим к следующей итерации
		
.end		[ r0 ] <- 0	; дополним строку завершающим нулём
		r3 <- [ sp ]	; восстановим регистры из стека
		r2 <- [ sp ]
		r1 <- [ sp ]
		ret		; выходим из процедуры
		
; zstrFromInt - конвертировать число со знаком в ASCIIZ-строку		
; вход:	r0 - указатель на буфер строки
;	r1 - число
; выход:	r0 - конец буфера строки
zstrFromInt	[ sp ] <- r1	; сохраним регистр в стек
		void <= r1	; тестируем знак
		jns .next		; если не отрицательное число - продолжаем
		[ r0 ] <- '-'	; иначе число отрицательно - запишем в буфер минус
		r0 <- r0 + 1	; увеличим указатель на буфер
		; и приведём число к положительному виду
		r1 = r1 ^ $FFFF	; инвертируем все биты
		r1 <- r1 + 1	; и прибавим 1 (это называется "дополнение до двух")
.next		call zstrFromNum	; а далее переложим заботу на процедуру беззнаковых
		r1 <- [ sp ]	; восстановим регистр из стека
		ret		; выходим из процедуры