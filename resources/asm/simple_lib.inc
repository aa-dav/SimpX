; SIMPLE_LIB - библиотека базовых процедур ввода-вывода SimpX

; Соглашения о вызовах:
; 1. параметры передаются в регистрах начиная с r0, r1...
; 2. результаты возвращаются так же в регистрах r0, r1...
; 3. процедуры сохраняет неизменными все регистры кроме psw

; Раскладка памяти:
; $0000 - крохотный раскрутчик прыгающий в итоге на пользовательскую 
;         метку start.
; $0010 - обработчик прерываний (по VBlank). Если irqExtHandler не 0, то
;         передаёт управление по этому адресу. Иначе инкрементирует 
;         irqTimer и выходит.
; Далее идёт код simple_lib, библиотек и в конце - пользовательский код.
; $7FFF - начало стека (растёт вниз)
; $8000-BFFF - 16Kw видеобитмапа (растровые данные экрана или символов тайлов/текста)
; $C000-C3FF - 1024 слов чармапа (32*32, видимая область 32*24, возможен скроллинг)
; $C400-CBFF - картинка со шрифтом (в формате экранной области)
; $CC00-FFDF - свободная зона
; $FFE0-FFFF - порты ввода-вывода

; *** КОНСТАНТЫ ***
; textBase - адрес начала текстовой области символов

; *** ПЕРЕМЕННЫЕ ***
; textPos		- позиция курсора текстового режима
; textAttrs	- атрибуты автоматически добавляемые в функциях печати к символу
; LastKey		- последняя нажатая кнопка (код USB-HID) (после вызова readKey)
; LastShifts	- последние зажатые шифты (после вызова readKey)

; *** ПРОЦЕДУРЫ ***
; loadPalette	- загрузить палитру
; simpleInit	- инициализировать раскладку памяти и текстовый видеорежим
; initTextMode	- инициализировать текстовый видеорежим
; initGraphicMode	- инициализируем графический режим
; printChar	- вывести один символ без учёта управляющих символов (быстро)
; cursorBack	- отодвинуть курсор назад, но не далее верхнего-левого края экрана
; printSpace	- напечатать пробел
; printCr		- перенести строку
; printTab	- вывести табуляцию
; printBkSp	- стереть символ слева и вернуть курсор назад
; printSpChar	- вывести символ с учётом управляющих символов
; printHex	- вывести число в 16-ричной форме
; printNum	- вывести беззнаковое число
; printInt	- вывести число со знаком
; readKey		- определить первую зажатую кнопку клавиатуры (обновляет LastKey)
; readKeyOnce	- как readKey, но возвращает 0 если кнопку не отжали
; decodeLastKey	- переводит код кнопки в LastKey в код ASCII-символа
; inputChar	- ждёт нажатия кнопки (блокирует) и возвращает код ASCII-символа

#include "simpx.inc"
		mode new	; "математический" режим ассемблера
		
bitmapBase	= $8000		; адрес начала битмапа
bitmapSize	= 256 * 256 / 4	; размер битмапа
charmapBase	= $C000		; адрес начала чармапа
textBase		= charmapBase	; ...что то же самое, что и текста в текстовом режиме
fontData		= $C400		; адрес начала данных шрифта (2 Kw)
textScreenSize	= 32 * 24		; размер видимого текста на экране в символах
textFullSize	= 32 * 32		; полный размер чармапа в символах
		
		org fontData	; Помещаем текущий адрес в fontData
#include "font-00.asm"	; загружаем битмап шрифта в fontData...
fontSize		= font-00_end - font-00	; размер данных шрифта

		org $0000	; Возвращаемся в адрес $0000 (стартовая точка процессора)
		psw <- $0000	; выключим прерывания
		sp <- $8000	; установим указатель на стек в $8000
		call simpleInit	; инициализируем простую библиотеку ввода-вывода
		pc <- start	; и переходим на начало программы

irqTimer		dw 0		; счётчик вызовов прерываний
irqExtHandler	dw 0		; адрес пользовательского обработчика прерываний
		org $0010		; адрес обработчика прерываний
irqHandler	void <= [ irqExtHandler ]	; проверим на 0 пользовательский обработчик
		jz .default		; если он 0 - идём на системный обработчик
		pc <- [ irqExtHandler ]	; иначе прыгаем в пользовательский
.default		[ irqTimer ] <- [ irqTimer ] + 1	; увеличим таймер
		; так надо выходить из прерывания:
		psw <- [ sp ]	; восстанавливаем psw
		pc <- [ sp ]	; выходим из прерывания (то же самое что и ret)
		
#include "zstr.inc"	; подключим функции по работе с ASCIIZ-строками		
#include "math.inc"	; подключим математические функции

; palette0 - простая палитра на 16 первых цветов по типу спектрумовской
; перебирает все комбинации вкл/выкл каналов RGB в первых 8 слотах
; и точно то же делает в последних 8 слотах, но с повышенной яркостью			 
palette0	; первые 16 слотов палитры, формат RRRRRGGGGGBBBBB
		; slot 0
		dw 000000000000000b
		dw 000000000010000b
		dw 000001000000000b
		dw 000001000010000b
		dw 100000000000000b
		dw 100000000010000b
		dw 100001000000000b
		dw 100001000010000b
		dw 011110111101111b
		dw 000000000011111b
		dw 000001111100000b
		dw 000001111111111b
		dw 111110000000000b
		dw 111110000011111b
		dw 111111111100000b
		dw 111111111111111b
		; slot 1
		dw 000000000000000b
		dw 000000000010000b
		dw 000001000000000b
		dw 000001000010000b
		dw 100000000000000b
		dw 100000000010000b
		dw 100001000000000b
		dw 100001000010000b
		dw 011110111101111b
		dw 000000000011111b
		dw 000001111100000b
		dw 000001111111111b
		dw 111110000000000b
		dw 111110000011111b
		dw 111111111100000b
		dw 000001111111111b ; !

; loadPalette - процедура по заполнению слотов палитры
; in:	r0 - адрес палитры в памяти
;	r1 - начальный слот палитры
;	r2 - количество слотов палитры к заполнению
loadPalette 
		[ sp ] <- r0	; сохраняем регистры в стек
		[ sp ] <- r1
		[ sp ] <- r2
.loop		[ vidPalPtr ] <- r1	; активируем слот палитры
		r1 <- r1 + 1	; заранее переходим к следующему
		[ vidPalData ] <- [ r0 ]	; пишем данные из буфера
		r0 <- r0 + 1	; переходим к следующий
		r2 <= r2 - 1	; уменьшаем счётчик
		jnz .loop		; и если он не ноль - повторяем итерацию
		r2 <- [ sp ]	; восстанавливаем регистры из стека
		r1 <- [ sp ]
		r0 <- [ sp ]
		ret	 	; выходим из процедуры

; simpleInit - инициализация простой тестовой среды выполнения
simpleInit	[ sp ] <- r0	; сохраняем регистры в стек
		[ sp ] <- r1
		[ sp ] <- r2
		[ vidBitmapPage ]   <- 4	; настраиваем видеобитмап на $8000-BFFF
		[ vidCharmapPage ]  <- 6	; настраиваем страницу чармапа на $C000
		[ vidCharmapAddr ]  <- 0	; и адрес в странице на $C000-C3FF
		psw = psw | IRQ_ENABLED	; включим прерывания
		; загрузим простую палитру
		r0 <- palette0
		r1 <- 0		   
		r2 <- 32
		call loadPalette
		; инициализируем текстовую раскладку видеоданных
		call initTextMode
		r2 <- [ sp ]		; восстанавливаем регистры из стека
		r1 <- [ sp ]
		r0 <- [ sp ]
		ret			; выходим из процедуры
		
textPos		dw textBase	; текущий адрес курсора в текстовых данных
textAttrs		dw 0	; верхняя тетрада - атрибуты символа к выводу

; initTextMode - инициализируем "текстовый режим"
; на самом деле в SimpX это не более чем упорядоченная определенным образом 
; раскладка видеоданных (чармап заполнен не линейно как в графическом режиме, а каждый
; его элемент и есть символ и его атрибуты цветности)
initTextMode
		[ sp ] <- r0		; сохраним регистры
		[ sp ] <- r1
		[ sp ] <- r2
		r0 = r0 - r0		; обнулим r0
		[ vidScrollX ] <- r0	; обнулим скроллинг экрана по X
		[ vidScrollY ] <- r0	; обнулим скроллинг экрана по Y
		[ textAttrs ] <- r0		; обнулим атрибуты
		; очистим чармап
		r0 <- textBase		; r0 - адрес начала текста
		[ textPos ] <- r0		; курсора в начало текстовой области
		r1 <- textFullSize		; r1 - полный размер текстовой области
		r2 = r2 - r2		; обнулим r2
.loop		[ r0 ] <- r2		; обнулим память
		r0 <- r0 + 1		; увеличим r0
		r1 <= r1 - 1		; уменьшим r1 обновив флаги
		jnz .loop			; если не получился ноль - повторяем цикл
		
		; зальём в битмап данные шрифта
		r0 <- bitmapBase		; в r0 - адрес куда копируем
		r1 <- fontData		; в r1 - адрес откуда копируем
		r2 <- fontSize		; в r2 - сколько слов копируем
.loop2		[ r0 ] <- [ r1 ]		; копируем слово
		r0 <- r0 + 1		; увеличиваем r0
		r1 <- r1 + 1		; увеличиваем r1
		r2 <= r2 - 1		; уменьшаем r2 с обновлением флагов
		jnz .loop2		; если не ноль - повторяем
		
		r2 <- [ sp ]		; восстанавливаем регистры из стека
		r1 <- [ sp ]
		r0 <- [ sp ]
		ret			; выходим из процедуры
		
; initGraphicMode - инициализируем "графический режим"
; на самом деле в SimpX это не более чем упорядоченная определенным образом 
; раскладка видеоданных (чармап заполнен линейно по нарастанию 0..1023, а значит
; битмап линейно отображается на экране как 4-битная экранная область. при этом
; верхние 4 бита в данных чармапа выбирают одну из 16 субпалитр в знакоместе 8x8)
initGraphicMode
		[ sp ] <- r0		; сохраним регистры
		[ sp ] <- r1
		[ sp ] <- r2
		r0 = r0 - r0		; обнулим r0
		[ vidScrollX ] <- r0	; обнулим скроллинг экрана по X
		[ vidScrollY ] <- r0	; обнулим скроллинг экрана по Y
		[ textAttrs ] <- r0		; обнулим атрибуты
		; зальём чармап по нарастанию
		r0 <- textBase		; r0 - адрес начала текста
		[ textPos ] <- r0		; курсора в начало текстовой области
		r1 <- textFullSize		; r1 - полный размер текстовой области
		r2 = r2 - r2		; обнулим r2
.loop		[ r0 ] <- r2		; зальём память
		r2 <- r2 + 1		; увеличим r2
		r0 <- r0 + 1		; увеличим r0
		r1 <= r1 - 1		; уменьшим r1 обновив флаги
		jnz .loop			; если не получился ноль - повторяем цикл
		
		; очистим экранную область
		r0 <- bitmapBase		; в r0 - адрес битмапа
		r1 <- bitmapSize		; в r1 - размер битмапа
		r2 = r2 - r2		; обнуляем r2
.loop2		[ r0 ] <- r2		; зануляем очередное слово битмапа
		r0 <- r0 + 1		; увеличиваем r0
		r1 <= r1 - 1		; уменьшаем r1 с обновлением флагов
		jnz .loop2		; если не ноль - повторяем
		
		r2 <- [ sp ]		; восстанавливаем регистры из стека
		r1 <- [ sp ]
		r0 <- [ sp ]
		ret			; выходим из процедуры		

; printChar - печать символа в r0 (ascii) в текстовом режиме
; in: r0 - символ для печати
printChar		[ sp ] <- r0
		[ sp ] <- r1		; сохраним регистры r0 и r1
		r0 = r0 - 32		; поправим код символа к началу битмапа
		r1 <- [ textPos ]		; r1 - адрес курсора на экране
		[ r1 ] = r0 | [ textAttrs ]	; запишем в знакоместо символ с атрибутами
		r1 <- r1 + 1		; увеличим адрес курсора
		; и сравним его с адресом последнего символа на экране:
		void = ( textBase + textScreenSize - 1 ) - r1
		jnc .end			; если переполнения нет - идём на выход
		; иначе настало время проскроллить экран на одну строку вверх...
		[ sp ] <- r2
		[ sp ] <- r3
		r2 <- textBase		; куда копируем
		r3 <- ( textBase + 32 )	; откуда копируем (строка ниже)
		r0 <- ( 32 * 23 )		; сколько копируем (без последней строки)
.loop_scroll	[ r2 ] <- [ r3 ]		; копируем слово из памяти в память
		r2 <- r2 + 1		; инкрементируем r2
		r3 <- r3 + 1		; инкрементируем r3
		r0 <= r0 - 1		; уменьшаем счётчик с обновлением флагов
		jnz .loop_scroll		; и если он не достиг нуля - повторяем цикл
		r0 <- 32			; нужно очистить последнюю строку
.loop_clear	[ r2 ] <- 0		; занулим адрес r2 (он изначально где надо)
		r2 <- r2 + 1		; увеличим r2
		r0 <= r0 - 1		; уменьшим счётчик с обновлением флагов
		jnz .loop_clear		; если не 0 - повторяем цикл
		r1 = r1 - 32		; поднимем указатель курсора на одну строку
		r3 <- [ sp ]		; восстановим дополнительные регистры из стека
		r2 <- [ sp ]
.end		[ textPos ] <- r1		; обновляем адрес курсора на экране
		r1 <- [ sp ]		; восстанавливаем r1 и r0 из стека
		r0 <- [ sp ]
		ret			; выходим из процедуры

; cursorBack - отодвинуть курсор на один символ назад, но не далее чем 
; левый-верхний угол экрана				
		; сравним позицию курсора с краем экрана:
cursorBack	void = [ textPos ] - ( textBase + 1 )	
		jc .end		; если уже на краю - пропускаем...
		[ textPos ] <- [ textPos ] - 1	; возвращаем textPos назад
.end		ret		; выходим из процедуры

; printSpace - напечатать пробел
printSpace	[ sp ] <- r0	; сохраним r0 в стек
		r0 <- ' '		; в r0 код пробела
		call printChar	; напечатаем символ в r0
		r0 <- [ sp ]	; восстанавливаем r0 из стека
		ret		; выходим из процедуры

; printCr - напечатать пробелов до начала следующей строки
printCr		[ sp ] <- r0	; сохраним r0 в стек
		r0 <- ' '		; запишем в r0 код пробела
.loop		call printChar	; напечатаем символ в r0 (пробел)
		void = [ textPos ] & 11111b	; проверим не обнулены ли нижние 5 бит в [ textPos ]
		jnz .loop		; если нет - повторяем цикл
		r0 <- [ sp ]	; восстанавливаем r0 из стека
		ret		; выходим из процедуры

; printTab - напечатать пробелов до следующей позиции табуляции
printTab		[ sp ] <- r0	; сохраним r0 в стек
		r0 <- ' '		; запишем в него код пробела
.loop		call printChar	; напечатаем символ в r0
		void = [ textPos ] & 00111b	; проверим не обнулены ли нижние 5 бит в [ textPos ]
		jnz .loop		; если нет - повторяем цикл
		r0 <- [ sp ]	; восстанавливаем r0 из стека
		ret		; выходим из процедуры

; printBkSp - вернуть курсор назад и стереть символ под ним
printBkSp		[ sp ] <- r0		; сохраняем r0 в стеке
		call cursorBack		; возвращаем курсор назад
		r0 <- [ textPos ]		; r0 - адрес курсора
		[ r0 ] <- ( ' ' - 32 )	; напрямую пишем в него код пробела
					; при этом нужно взять поправку на 
					; начало таблицы символов в битмапе
		r0 <- [ sp ]		; восстанавливаем r0 из стека
		ret			; возвращаемся из процедуры

; printSpChar - напечатать символ с учётом спец-знаков (ENTER, BACKSPACE и TAB)				
; вход:	r0 - символ
printSpChar	void = r0 - 13	; сравним с переводом строки
		jz printCr	; если он - идём на соответствующую процедуру
		void = r0 - 9	; сравним с Tab
		jz printTab	; если он - идём на соответствующую процедуру
		void = r0 - 8	; сравним с BackSpace
		jz printBkSp	; если он - идём на соответствующую процедуру
		pc <- printChar	; если не всё вышеперечисленное - идём в printChar

printBuf		ds 10 0		; буфер с запасом для функций печати ниже...

; printHex - печать числа в r0 как hex		  
; in: r0 - число для печати
printHex		[ sp ] <- r0	; сохраним регистры в стек
		[ sp ] <- r1		
		r1 <- r0		; ф-я zstrFromHex ожидает число в r1
		r0 <- printBuf	; а в r0 - указатель на строковой буфер
		call zstrFromHex	; сконвертируем число в строку (hex)
		r0 <- printBuf	; снова нацелим r0 на буфер
		call zstrPrint	; и распечатаем его		
		r1 <- [ sp ]	; восстанавливаем регистры из стека
		r0 <- [ sp ]
		ret		; выходим из процедуры

; printNum - печать числа в r0 как беззнакового
; in: r0 - число для печати
printNum		[ sp ] <- r0	; сохраняем регистры в стек
		[ sp ] <- r1		
		r1 <- r0		; ф-я zstrFromHex ожидает число в r1
		r0 <- printBuf	; а в r0 - указатель на строковой буфер
		call zstrFromNum	; сконвертируем число в строку (беззнаковое число)
		r0 <- printBuf	; снова нацелим r0 на буфер
		call zstrPrint	; и распечатаем его				
		r1 <- [ sp ]	; восстанавливаем регистры из стека
		r0 <- [ sp ]
		ret		; выходим из процедуры

; printInt - печать числа в r0 как числа со знаком
; in: r0 - число для печати
printInt		[ sp ] <- r0	; сохраняем регистры в стек
		[ sp ] <- r1		
		r1 <- r0		; ф-я zstrFromHex ожидает число в r1
		r0 <- printBuf	; а в r0 - указатель на строковой буфер
		call zstrFromInt	; сконвертируем число в строку (число со знаком)
		r0 <- printBuf	; снова нацелим r0 на буфер
		call zstrPrint	; и распечатаем его					
		r1 <- [ sp ]	; восстанавливаем регистры из стека
		r0 <- [ sp ]
		ret 		; выходим из процедуры

LastKey		dw 0	; последняя нажатая кнопка (код USB-HID)
LastShifts	dw 0	; последние нажатые шифты (нижние три бита)

; readKey - считать код нажатой кнопки
; обновляет LastKey и LastShift
; выход:	r0 - код первой нажатой кнопки (0 если нет нажатий)
readKey		[ sp ] <- r1          ; сохраняем регистры в стек
		[ sp ] <- r2
		[ sp ] <- r3
		r1 <- 1		  ; в r1 линия 1
		[ portInput ] <- r1	  ; активируем линию 1
		r2 <- [ portInput ]	  ; считаем данные из линии 1
		[ LastShifts ] = r2 & 111b ; выделим и запомним шифты
		r3 = r3 - r3	  ; обнулим r3 - счётчик
		r0 = r0 - r0	  ; обнулим r0 - результат
		r2 = r2 & $FFF8	  ; удалим шифты из рассмотрения
.loop_keys	; в r2 следующий ряд, флаг z обновлён!
		jnz .loop_found	  ; тут где то нажата кнопка!
		r3 = r3 + 16	  ; продвигаем счётчик на 16 кнопок
		r1 = r1 + r1	  ; сдвинем r1 влево (умножение на 2)
		void = r1 - $100	  ; проверим на выход за 8 линий клавиатуры
		jz .end		  ; если вышли за пределы - идём на выход
		[ portInput ] <- r1	  ; обновим линию в portInput
		r2 <= [ portInput ]	  ; считаем кнопки с обновлением флагов
		pc <- .loop_keys	  ; идём в начало цикла
.loop_found	; в r2 считанный ряд, в r3 счётчик базы ряда кнопок
		; осталось довычислить по первому зажжёному биту в r2 номер кнопки
		r3 <- r3 + 1          ; увеличим счётчик
		r2 <= r2 >> 1         ; прокрутим r2 на бит право, при этом самый нижний
		jnc .loop_found       ; бит попадает во флаг Carry - если он не 1 повторяем...
		r0 <- r3              ; результат отправляется в r0
.end		[ LastKey ] <- r0     ; обновим LastKey
.exit		r3 <- [ sp ]          ; восстанавливаем регистры из стека
		r2 <- [ sp ]
		r1 <- [ sp ]
		ret                   ; выходим из процедуры

; readKeyOnce - считать нажатие клавиши без повторов
; обновляет LastKey и LastShifts
; возвращает 0, если клавиша была нажата в предыдущий вызов
; выход:	r0 - код нажатой клавиши				
readKeyOnce	[ sp ] <- r1	; сохраняем регистры в стек
		r1 <- [ LastKey ]	; запоминаем в r1 LastKey
		call readKey	; определяем зажатую кнопку
		void = r1 - r0	; проверяем не равна ли она LastKey
		jnz .end		; если нет - идём на выход
		r0 = r0 - r0	; иначе обнуляем результат
.end		r1 <- [ sp ]	; восстанавливаем регистры из стека
		ret		; выходим из процедуры

; keysToChars - таблица соответствий кодов клавиш и ASCII-символов
; в нижнем байте лежит код символа без шифта, в верхнем - с зажатым шифтом.
keysToChars	dw ( 'a' + ( 'A' << 8 ) ) ; 4th
		dw ( 'b' + ( 'B' << 8 ) )
		dw ( 'c' + ( 'C' << 8 ) )
		dw ( 'd' + ( 'D' << 8 ) )
		dw ( 'e' + ( 'E' << 8 ) )
		dw ( 'f' + ( 'F' << 8 ) )
		dw ( 'g' + ( 'G' << 8 ) )
		dw ( 'h' + ( 'H' << 8 ) )
		dw ( 'i' + ( 'I' << 8 ) )
		dw ( 'j' + ( 'J' << 8 ) )
		dw ( 'k' + ( 'K' << 8 ) )
		dw ( 'l' + ( 'L' << 8 ) )
		dw ( 'm' + ( 'M' << 8 ) )
		dw ( 'n' + ( 'N' << 8 ) )
		dw ( 'o' + ( 'O' << 8 ) )
		dw ( 'p' + ( 'P' << 8 ) )
		dw ( 'q' + ( 'Q' << 8 ) )
		dw ( 'r' + ( 'R' << 8 ) )
		dw ( 's' + ( 'S' << 8 ) )
		dw ( 't' + ( 'T' << 8 ) )
		dw ( 'u' + ( 'U' << 8 ) )
		dw ( 'v' + ( 'V' << 8 ) )
		dw ( 'w' + ( 'W' << 8 ) )
		dw ( 'x' + ( 'X' << 8 ) )
		dw ( 'y' + ( 'Y' << 8 ) )
		dw ( 'z' + ( 'Z' << 8 ) )
		dw ( '1' + ( '!' << 8 ) )
		dw ( '2' + ( '@' << 8 ) )
		dw ( '3' + ( '#' << 8 ) )
		dw ( '4' + ( '$' << 8 ) )
		dw ( '5' + ( '%' << 8 ) )
		dw ( '6' + ( '^' << 8 ) )
		dw ( '7' + ( '&' << 8 ) )
		dw ( '8' + ( '*' << 8 ) )
		dw ( '9' + ( '(' << 8 ) )
		dw ( '0' + ( ')' << 8 ) )
		dw ( 13 + ( 13 << 8 ) )
		dw ( 27 + ( 27 << 8 ) ) ; esc
		dw ( 8 + ( 8 << 8 ) ) ; bksp
		dw ( 9 + ( 9 << 8 ) ) ; tab
		dw ( ' ' + ( ' ' << 8 ) )
		dw ( '-' + ( '_' << 8 ) )
		dw ( '=' + ( '+' << 8 ) )
		dw ( '[' + ( '{' << 8 ) )
		dw ( ']' + ( '}' << 8 ) )
		dw ( '\' + ( '|' << 8 ) )
		dw ( '#' + ( '~' << 8 ) ) ; hashtilde
		dw ( ';' + ( ':' << 8 ) )
		dw ( ''' + ( '"' << 8 ) )
		dw ( '`' + ( '~' << 8 ) )
		dw ( ',' + ( '<' << 8 ) )
		dw ( '.' + ( '>' << 8 ) )
		dw ( '/' + ( '?' << 8 ) )
		dw 0	; capslock

; decodeLastKey - возвращает ASCII-код последней нажатой клавиши
; выход:	r0 - ASCII-код из LastKey
decodeLastKey	; настраиваем r0 на адрес в памяти - начало таблицы конверсии
		; символов плюс код нажатой кнопки, но т.к. таблица сдвинута
		; на шифты надо поправить базовый адрес на -4 - это делается
		; вычислением времени компиляции в выражении в круглых скобках:
		r0 = ( keysToChars - 4 ) + [ LastKey ]
		r0 <- [ r0 ]	; считываем слово из таблицы
		void = [ LastShifts ] & 2 ; проверяем был ли зажат шифт
		jz .skip_shift	; если нет - идём на выход
		r0 = r0 >> 8	; иначе меняем байты в r0 местами
.skip_shift	r0 = r0 & $FF	; оставляем только нижний байт
		ret		; выходим из процедуры
		
; inputChar - блокирующий ввод ASCII-символа с клавиатуры
inputChar		[ sp ] <- r1	; сохраняем регистры
		; таймер инкрементируется обработчиком прерывания 60 раз
		; в секунду. Пятый бит соответствующий довичному разряду 32 
		; будет меняться таким образом примерно два раза в секунду.
		; Воспользуемся этим для мигания курсора
.loop		void = [ irqTimer ] & 10000b	; тестируем пятый бит в irqTimer
		r0 <- ( ' ' - 32 )	; записываем в r0 код пробела (с поправкой)
		jz .show_cursor	; если бит был нулевой - пропускаем следующее
		r0 <- ( '_' - 32 )	; если бит единичный - берём код подчёркивания
.show_cursor	r1 <- [ textPos ]	; r1 указывает напрямую на символ в видеопамяти
		[ r1 ] <- r0	; запишем в него r0 для мигающего курсора
		call readKeyOnce	; считаем единожды клавишу
		r0 <= r0		; протестируем содержимое r0
		jz .loop		; если ноль - повторяем цикл
		[ r1 ] <- ( ' ' - 32 )	; стираем возможный символ _ от курсора
		call decodeLastKey	; декодируем введённый символ в ASCII
		r1 <- [ sp ]	; восстанавливаем регистры из стека
		ret		; выходим из процедуры
		