#include "simpx.inc"
		mode new	; "математический" режим ассемблера
		org $8000	; Помещаем текущий адрес в $8000
#include "font-00.asm"	; загружаем битмап шрифта в $8000...

		org $0000	; Возвращаемся в адрес $0000 (стартовая точка процессора)
		psw <- $0000	; выключим прерывания
		sp <- $8000	; установим указатель на стек в $8000
		call simpleInit	; инициализируем простую библиотеку ввода-вывода
		pc <- start	; и переходим на начало программы

irqTimer		dw 0		; счётчик вызовов прерываний
irqExtHandler	dw 0		; адрес пользовательского обработчика прерываний
		org $0010		; адрес обработчика прерываний
irqHandler	void <= [ irqExtHandler ]	; проверим на 0 пользовательский обработчик
		jz .default		; если он 0 - идём на системный обработчик
		pc <- [ irqExtHandler ]	; иначе прыгаем в пользовательский
.default		[ irqTimer ] <- [ irqTimer ] + 1	; увеличим таймер
		psw <- [ sp ]			; восстанавливаем psw
		pc <- [ sp ]			; выходим из прерывания
		
#include "zstr.inc"	; подключим функции по работе с ASCIIZ-строками		

; palette0 - простая палитра на 16 первых цветов по типу спектрумовской
; перебирает все комбинации вкл/выкл каналов RGB в первых 8 слотах
; и точно то же делает в последних 8 слотах, но с повышенной яркостью			 
palette0	; первые 16 слотов палитры, формат RRRRRGGGGGBBBBB
		; slot 0
		dw 000000000000000b
		dw 000000000010000b
		dw 000001000000000b
		dw 000001000010000b
		dw 100000000000000b
		dw 100000000010000b
		dw 100001000000000b
		dw 100001000010000b
		dw 011110111101111b
		dw 000000000011111b
		dw 000001111100000b
		dw 000001111111111b
		dw 111110000000000b
		dw 111110000011111b
		dw 111111111100000b
		dw 111111111111111b
		; slot 1
		dw 000000000000000b
		dw 000000000010000b
		dw 000001000000000b
		dw 000001000010000b
		dw 100000000000000b
		dw 100000000010000b
		dw 100001000000000b
		dw 100001000010000b
		dw 011110111101111b
		dw 000000000011111b
		dw 000001111100000b
		dw 000001111111111b
		dw 111110000000000b
		dw 111110000011111b
		dw 111111111100000b
		dw 000001111111111b ; !

; loadPalette - процедура по заполнению слотов палитры
; in:	r0 - адрес палитры в памяти
;	r1 - начальный слот палитры
;	r2 - количество слотов палитры к заполнению
loadPalette 
		[ sp ] <- r0	; сохраняем регистры в стек
		[ sp ] <- r1
		[ sp ] <- r2
.loop		[ vidPalPtr ] <- r1	; активируем слот палитры
		r1 <- r1 + 1	; заранее переходим к следующему
		[ vidPalData ] <- [ r0 ]	; пишем данные из буфера
		r0 <- r0 + 1	; переходим к следующий
		r2 <= r2 - 1	; уменьшаем счётчик
		jnz .loop		; и если он не ноль - повторяем итерацию
		r2 <- [ sp ]	; восстанавливаем регистры из стека
		r1 <- [ sp ]
		r0 <- [ sp ]
		ret	 	; выходим из процедуры

; simpleInit - инициализация простой тестовой среды выполнения
simpleInit	[ sp ] <- r0	; сохраняем регистры в стек
		[ sp ] <- r1
		[ sp ] <- r2
		[ vidBitmapPage ]   <- 4	; настраиваем видеобитмап на $8000-BFFF
		[ vidCharmapPage ]  <- 6	; настраиваем страницу чармапа на $C000
		[ vidCharmapAddr ]  <- 0	; и адрес в странице на $C000-C3FF
		psw = psw | IRQ_ENABLED	; включим прерывания
		; загрузим простую палитру
		r0 <- palette0
		r1 <- 0		   
		r2 <- 32
		call loadPalette
		; инициализируем текстовую раскладку видеоданных
		call initTextMode
		r2 <- [ sp ]		; восстанавливаем регистры из стека
		r1 <- [ sp ]
		r0 <- [ sp ]
		ret			; выходим из процедуры
		
textBase		= $C000	; адрес начала текстовых данных экрана
textPos		dw textBase	; текущий адрес курсора в текстовых данных
textAttrs		dw 0	; верхняя тетрада - атрибуты символа к выводу
textScreenSize	= 32 * 24	; размер видимого текста на экране в символах

; initTextMode - инициализируем "текстовый режим"
; на самом деле в SimpX это не более чем упорядоченная определенным образом 
; раскладка видеоданных (чармап заполнен не линейно как в графическом режиме, а каждый
; его элемент и есть символ и его атрибуты цветности)
initTextMode
		[ sp ] <- r0		; сохраним регистры
		[ sp ] <- r1
		r0 = r0 - r0		; обнулим r0
		[ vidScrollX ] <- r0	; обнулим скроллинг экрана по X
		[ vidScrollY ] <- r0	; обнулим скроллинг экрана по Y
		[ textAttrs ] <- r0		; обнулим атрибуты
		r0 <- textBase		; r0 - адрес начала текста
		[ textPos ] <- r0		; курсора в начало текстовой области
		r1 <- ( 32 * 32 )		; r1 - полный размер текстовой области
.loop		[ r0 ] <- 0		; обнулим память
		r0 <- r0 + 1		; увеличим r0
		r1 <= r1 - 1		; уменьшим r1 обновив флаги
		jnz .loop			; если не получился ноль - повторяем цикл
		r1 <- [ sp ]		; восстанавливаем регистры из стека
		r0 <- [ sp ]
		ret			; выходим из процедуры
		
		

; printChar - печать символа в r0 (ascii) в текстовом режиме
; in: r0 - символ для печати
printChar		[ sp ] <- r0
		[ sp ] <- r1		; сохраним регистры r0 и r1
		r0 = r0 - 32		; поправим код символа к началу битмапа
		r1 <- [ textPos ]		; r1 - адрес курсора на экране
		[ r1 ] = r0 | [ textAttrs ]	; запишем в знакоместо символ с атрибутами
		r1 <- r1 + 1		; увеличим адрес курсора
		; и сравним его с адресом последнего символа на экране:
		void = ( textBase + textScreenSize - 1 ) - r1
		jnc .end			; если переполнения нет - идём на выход
		; иначе настало время проскроллить экран на одну строку вверх...
		[ sp ] <- r2
		[ sp ] <- r3
		r2 <- textBase		; куда копируем
		r3 <- ( textBase + 32 )	; откуда копируем (строка ниже)
		r0 <- ( 32 * 23 )		; сколько копируем (без последней строки)
.loop_scroll	[ r2 ] <- [ r3 ]		; копируем слово из памяти в память
		r2 <- r2 + 1		; инкрементируем r2
		r3 <- r3 + 1		; инкрементируем r3
		r0 <= r0 - 1		; уменьшаем счётчик с обновлением флагов
		jnz .loop_scroll		; и если он не достиг нуля - повторяем цикл
		r0 <- 32			; нужно очистить последнюю строку
.loop_clear	[ r2 ] <- 0		; занулим адрес r2 (он изначально где надо)
		r2 <- r2 + 1		; увеличим r2
		r0 <= r0 - 1		; уменьшим счётчик с обновлением флагов
		jnz .loop_clear		; если не 0 - повторяем цикл
		r1 = r1 - 32		; поднимем указатель курсора на одну строку
		r3 <- [ sp ]		; восстановим дополнительные регистры из стека
		r2 <- [ sp ]
.end		[ textPos ] <- r1		; обновляем адрес курсора на экране
		r1 <- [ sp ]		; восстанавливаем r1 и r0 из стека
		r0 <- [ sp ]
		ret			; выходим из процедуры

; cursorBack - отодвинуть курсор на один символ назад, но не далее чем 
; левый-верхний угол экрана				
		; сравним позицию курсора с краем экрана:
cursorBack	void = [ textPos ] - ( textBase + 1 )	
		jc .end		; если уже на краю - пропускаем...
		[ textPos ] <- [ textPos ] - 1	; возвращаем textPos назад
.end		ret		; выходим из процедуры

; printCr - напечатать пробелов до начала следующей строки
printCr		[ sp ] <- r0	; сохраним r0 в стек
		r0 <- ' '		; запишем в r0 код пробела
.loop		call printChar	; напечатаем символ в r0 (пробел)
		void = [ textPos ] & 11111b	; проверим не обнулены ли нижние 5 бит в [ textPos ]
		jnz .loop		; если нет - повторяем цикл
		r0 <- [ sp ]	; восстанавливаем r0 из стека
		ret		; выходим из процедуры

; printTab - напечатать пробелов до следующей позиции табуляции
printTab		[ sp ] <- r0	; сохраним r0 в стек
		r0 <- ' '		; запишем в него код пробела
.loop		call printChar	; напечатаем символ в r0
		void = [ textPos ] & 00111b	; проверим не обнулены ли нижние 5 бит в [ textPos ]
		jnz .loop		; если нет - повторяем цикл
		r0 <- [ sp ]	; восстанавливаем r0 из стека
		ret		; выходим из процедуры

; printBkSp - вернуть курсор назад и стереть символ под ним
printBkSp		[ sp ] <- r0		; сохраняем r0 в стеке
		call cursorBack		; возвращаем курсор назад
		r0 <- [ textPos ]		; r0 - адрес курсора
		[ r0 ] <- ( ' ' - 32 )	; напрямую пишем в него код нуля
		r0 <- [ sp ]		; восстанавливаем r0 из стека
		ret			; возвращаемся из процедуры

; printSpChar - напечатать символ с учётом спец-знаков (ENTER, BACKSPACE и TAB)				
; вход:	r0 - символ
printSpChar	void = r0 - 13	; сравним с переводом строки
		jz printCr	; если он - идём на соответствующую процедуру
		void = r0 - 9	; сравним с Tab
		jz printTab	; если он - идём на соответствующую процедуру
		void = r0 - 8	; сравним с BackSpace
		jz printBkSp	; если он - идём на соответствующую процедуру
		pc <- printChar	; если не всё вышеперечисленное - идём в printChar

hexNumbers	dw "0123456789ABCDEF"	; массив 16-ричных цифр

; printHex - печать числа в r0 как hex		  
; in: r0 - число для печати
printHex		
		[ sp ] <- r0
		[ sp ] <- r1
		r1 <- r0

		r1 <= r1 >> 12
		r0 = r1 & $000F
		r0 = hexNumbers + r0
		r0 <- [ r0 ]
		call printChar

		r1 <= r1 >> 12
		r0 = r1 & $000F
		r0 = hexNumbers + r0
		r0 <- [ r0 ]
		call printChar

		r1 <= r1 >> 12
		r0 = r1 & $000F
		r0 = hexNumbers + r0
		r0 <- [ r0 ]
		call printChar

		r1 <= r1 >> 12
		r0 = r1 & $000F
		r0 = hexNumbers + r0
		r0 <- [ r0 ]
		call printChar
						
		r1 <- [ sp ]
		r0 <- [ sp ]
		ret 

LastKey		dw 0	; последняя нажатая кнопка
LastShifts	dw 0	; последние нажатые шифты

; readKey - считать код нажатой кнопки
; обновляет LastKey и LastShift
; выход:	r0 - код первой нажатой кнопки (0 если нет нажатий)
readKey		[ sp ] <- r1
		[ sp ] <- r2
		[ sp ] <- r3
		r1 <- 1		  ; в r1 линия 1
		[ portInput ] <- r1	  ; активируем линию 1
		r2 <- [ portInput ]	  ; считаем данные из линии 1
		[ LastShifts ] = r2 & 111b ; выделим и запомним шифты
		r3 = r3 - r3	  ; обнулим r3 - счётчик
		r0 = r0 - r0	  ; обнулим r0 - результат
		r2 = r2 & $FFF8	  ; удалим шифты из рассмотрения
.loop_keys	; в r2 следующий ряд, флаг z обновлён!
		jnz .loop_found	  ; тут где то нажата кнопка!
		r3 = r3 + 16	  ; продвигаем счётчик на 16 кнопок
		r1 = r1 + r1	  ; сдвинем r1 влево (умножение на 2)
		void = r1 - $100	  ; проверим на выход за 8 линий клавиатуры
		jz .end		  ; если вышли за пределы - идём на выход
		[ portInput ] <- r1	  ; обновим линию в portInput
		r2 <= [ portInput ]	  ; считаем кнопки с обновлением флагов
		pc <- .loop_keys	  ; идём в начало цикла
.loop_found	; в r2 считанный ряд, в r3 счётчик
		r3 <- r3 + 1
		r2 <= r2 >> 1
		jnc .loop_found
		r0 <- r3
.end		; в r0 результат
		[ LastKey ] <- r0
.exit		r3 <- [ sp ]
		r2 <- [ sp ]
		r1 <- [ sp ]
		ret

; readKeyOnce - считать нажатие клавиши без повторов
; обновляет LastKey и LastShifts
; возвращает 0, если клавиша была нажата в предыдущий вызов
; выход:	r0 - код нажатой клавиши				
readKeyOnce	[ sp ] <- r1
		r1 <- [ LastKey ]
		call readKey
		void = r1 - r0
		jnz .end
		r0 = r0 - r0
.end		r1 <- [ sp ]
		ret

; keysToChars - таблица соответствий кодов клавиш и ASCII-символов
keysToChars	dw ( 'a' + ( 'A' << 8 ) ) ; 4th
		dw ( 'b' + ( 'B' << 8 ) )
		dw ( 'c' + ( 'C' << 8 ) )
		dw ( 'd' + ( 'D' << 8 ) )
		dw ( 'e' + ( 'E' << 8 ) )
		dw ( 'f' + ( 'F' << 8 ) )
		dw ( 'g' + ( 'G' << 8 ) )
		dw ( 'h' + ( 'H' << 8 ) )
		dw ( 'i' + ( 'I' << 8 ) )
		dw ( 'j' + ( 'J' << 8 ) )
		dw ( 'k' + ( 'K' << 8 ) )
		dw ( 'l' + ( 'L' << 8 ) )
		dw ( 'm' + ( 'M' << 8 ) )
		dw ( 'n' + ( 'N' << 8 ) )
		dw ( 'o' + ( 'O' << 8 ) )
		dw ( 'p' + ( 'P' << 8 ) )
		dw ( 'q' + ( 'Q' << 8 ) )
		dw ( 'r' + ( 'R' << 8 ) )
		dw ( 's' + ( 'S' << 8 ) )
		dw ( 't' + ( 'T' << 8 ) )
		dw ( 'u' + ( 'U' << 8 ) )
		dw ( 'v' + ( 'V' << 8 ) )
		dw ( 'w' + ( 'W' << 8 ) )
		dw ( 'x' + ( 'X' << 8 ) )
		dw ( 'y' + ( 'Y' << 8 ) )
		dw ( 'z' + ( 'Z' << 8 ) )
		dw ( '1' + ( '!' << 8 ) )
		dw ( '2' + ( '@' << 8 ) )
		dw ( '3' + ( '#' << 8 ) )
		dw ( '4' + ( '$' << 8 ) )
		dw ( '5' + ( '%' << 8 ) )
		dw ( '6' + ( '^' << 8 ) )
		dw ( '7' + ( '&' << 8 ) )
		dw ( '8' + ( '*' << 8 ) )
		dw ( '9' + ( '(' << 8 ) )
		dw ( '0' + ( ')' << 8 ) )
		dw ( 13 + ( 13 << 8 ) )
		dw ( 27 + ( 27 << 8 ) ) ; esc
		dw ( 8 + ( 8 << 8 ) ) ; bksp
		dw ( 9 + ( 9 << 8 ) ) ; tab
		dw ( ' ' + ( ' ' << 8 ) )
		dw ( '-' + ( '_' << 8 ) )
		dw ( '=' + ( '+' << 8 ) )
		dw ( '[' + ( '{' << 8 ) )
		dw ( ']' + ( '}' << 8 ) )
		dw ( '\' + ( '|' << 8 ) )
		dw ( '#' + ( '~' << 8 ) ) ; hashtilde
		dw ( ';' + ( ':' << 8 ) )
		dw ( ''' + ( '"' << 8 ) )
		dw ( '`' + ( '~' << 8 ) )
		dw ( ',' + ( '<' << 8 ) )
		dw ( '.' + ( '>' << 8 ) )
		dw ( '/' + ( '?' << 8 ) )
		dw 0	; capslock

; decodeLastKey - возвращает ASCII-код последней нажатой клавиши
; выход:	r0 - ASCII-код из LastKey
decodeLastKey	r0 = ( keysToChars - 4 ) + [ LastKey ]
		r0 <- [ r0 ]
		void = [ LastShifts ] & 2 ; shift
		jz .skip_shift
		r0 = r0 >> 8
.skip_shift	r0 = r0 & $FF		
		ret
		
; inputChar - блокирующий ввод ASCII-символа с клавиатуры
inputChar		[ sp ] <- r1
.loop		void = [ irqTimer ] & 10000b
		r0 <- ( ' ' - 32 )
		jz .show_cursor
		r0 <- ( '_' - 32 )
.show_cursor	r1 <- [ textPos ]
		[ r1 ] <- r0
		call readKeyOnce
		r0 <= r0
		jz .loop
		[ r1 ] <- ( ' ' - 32 )
		call decodeLastKey
		r1 <- [ sp ]
		ret