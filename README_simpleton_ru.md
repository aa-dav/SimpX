# Simpleton 4

Некоторые видео ютубера 8bit-guy включая про 'Gigatron TTL' вдохновили меня придумать некоторую простую процессорную архитектуру (ISA).
Это четвёртое её поколение пытающееся использовать одну и ту же идею.

Во первых, эта ISA субоптимальна.

**Главная цель - это сделать формат инструкции как можно более простым сохраняя программирование тоже простым, но гибким и не эзотерическим.**

Я знаю, что плотность когда можно улучшить и получиться что то наподобие MSP 430, но это не вариант. :)

Во вторых, для простоты и регистры и ячейки памяти 16-битны.
Имеется восемь регистров r0-r7 и 128Кб или 65536 ячеек 16-битной памяти.

Поэтому опкод инструкции тоже 16-битен. И есть только один формат инструкции:  
![Instruction format picture](https://cdn.jpg.wtf/futurico/95/66/1613283583-9566e916e4b56fca243a37105c20898d.png)

Каждая инструкция делает только одну вещь: берёт два операнда X и Y, записывает их в АЛУ (арифметико-логическое устройство) с кодом инструкции и получив результат записывает его в R. Даже вызовы процедур или условные переходы делают только это.
Поля X, Y и R в инструкции это просто номера регистров 0-7. Плюс биты косвенности (XI, YI, RI) которые если установлены, то значит мы работаем с ячейкой памяти с адресом из соответствующего регистра. Замечу, что формат 4:4:4:4 позволяет легко считывать смысл инструкции прямо по её 16-ричному коду.
Таким образом любая инструкция выполняет выражение: R = Y op X, где 'op' это код операции. Квадратные скобки вокруг любого из операндов означают режим косвенности (бит косвенности = 1).


Регистры **r5-r7** имеют псевдонимы и особый функционал:
- **r5 = sp** - указатель стека - пост-инкрементируется после косвенного чтения и пре-декрементируется после косвенной записи.
- **r6 = pc** - счётчик инструкций - всегда пост-инкрементируется после косвенного чтения. Именно из него процессор считывает поток команд. Косвенная запись в pc не имеет смысла и процессор отменяет такую запись. Т.е. АЛУ исполняет операцию, обновляет регистр флагов, но результат никуда не записывается. В таком случае можно использовать еще псевдоним 'void'.
- **r7 = psw** = processor status word (регистр флагов). Косвенные чтения/запись в него бесмысленны, но такую комбинацию выбрать можно и она работает как режим адресации 'непосредственный адрес' ('immediate indirect') (данное из [ pc++ ] служит как адрес ячейки памяти откуда берется аргумент или куда записывается результат).

Технически непосредственные данные (числовые константы) в X или Y реализуются как косвенное чтение из pc, т.к. после такого чтения он автоматически увеличится (как всегда это делает) и будет указывать на следующее слово/инструкцию в памяти.
Во время исполнения инструкции операнды и результат считываются из [ pc++ ] (если надо) в следующем порядке: X, Y, R. Вот почему проще говорить о форме инструкции как R = Y + X.
Первые четыре опкода (0-3) инструкций трактуют поле XI+X как четырёхбитное 'inplace immediate' - константа встроенная в инструкцию -8..+7 или 0..15. В ассемблерной мнемонике такие инструкции имеют суффикс (возможно один из) 'i'.

Итак, давайте уже рассмотрим несколько инструкций в классическом ассемблерном синтаксисе:
```
add r0 r1 r2		; сложение регистров: r0 = r1 + r2
adc r1 r1 r3		; сложение с учётом флага переноса: r1 = r1 +c r3
add [ r2 ] 100 r4		; сложить r4 с константой ( режим адресации [ pc ] ) 100 и записать в ячейку памяти с адресом r2: [ r2 ] = 100 + r4
add [ r3 ] r4 [ $200 ]		; взять из ячейки памяти с адресом $200 (16-ричный адрес/число) число, сложить с r4 и записать в [ r3 ]: [ r3 ] = r4 + [ $200 ]
add [ 100 ] [ 20 ] [ 30 ]	; работаем с ячейками памяти минуя регистры (вся инструкция будет занимать четыре слова): [ 100 ] = [ 20 ] + [ 30 ]
```
Заметьте, что в синтаксисе этого ассемблера нет запятых между аргументами, поэтому если аргумент является сложным выражением времени компиляции, то его надо заключать в круглые скобки:
```
add r0 r0 (label + 4 * offset)	; в скобках может быть сложное выражение вычислимое на этапе компиляции
```

Как понятно всего возможно 16 кодов операций максимум. Сейчас реализованы следующие:
- 00 **ADDIS** - сложить Y с inplace immediate в X (-8..+7) без обновления флагов (S - silent, т.е. без обновления флагов)
- 01 **ADDI** - сложить Y с inplace immediate в X (-8..+7)
- 02 **RRCI** - прокрутка Y вправо (в русской литературе обычно переводят как 'циклический сдвиг') на INPLACE immediate (0..15) бит, во флаг переноса заносится последний перенесённый бит

- 04 **ADDS** - сложение без обновления флагов (silent)
- 05 **ADD** - сложение
- 06 **ADC** - сложение с учётом флага переноса
- 07 **SUB** - вычитение
- 08 **SBC** - вычитание с учётом флага переноса
- 09 **AND** - and
- 0A **OR** - or
- 0B **XOR** - xor
- 0C **CADD** - условное сложение. не обновляет флаги. см. ниже.
- 0D **RRC** - прокрутка Y вправо на X бит, во флаг переноса заносится последний перенесённый бит

## ПОЯСНЕНИЯ:

1. Для обычной для других процессоров инструкции 'move' здесь нет опкода, т.к. это 'addis' с X=0.
Однако, для простоты ассемблер поддерживает псевдоинструкцию 'move A B' которая превращается в 'addis A B 0'.
Вообще в инструкции addis X может быть опущен и станет равен 0.
```
addis r0 r1 1 ; прибавляем 1 к r1 и записываем результат в r0
addis r0 r1 0 ; прибавляем 0 к r1 и записываем результат (т.е. просто r1) в r0
move [ r2 ] r1 		; Копируем r1 в ячейку памяти куда указывает r2 (превратится в addis [ r2 ] r1 0)
move [ r3 ] [ 100 ]	; Копируем из ячейки памяти с адресом 100 в r3
```
2. Запись в pc есть ничто иное как переход, причём через операцию сложения легко реализуюется переход относительный:
```
move pc address		; переход на address
adds pc pc offset	; относительный переход на смещение
```
3. Условное сложение - ключ к условным переходам. Оно работает так: аргумент X (16-битный) раскладывается на две части: старшие 4 бита кодируют условие, а нижние 12 бит расширяются со знаком в слагаемое -2048..+2047 (смещение). Т.е. код условия не является частью опкода, а является частью данных! Если условие срабатывает, то АЛУ складывает смещение с Y и записывает результат в R. Иначе в R попадает Y в неизменном виде.
Таким образом, чтобы реализовать условный переход нам надо сделать:
```
cadd pc pc условие_и_смещение
```
Для простоты и привычности ассемблер предоставляет псевдонимы для последнего в виде привычных условных переходов вида 'j** адрес', где ** - это мнемонический код условия.
Например:
```
jnz label	; перейти на label если не зажжён флаг нуля (метка должна быть в пределах 2Kw от текущего pc!)
```
Возможные коды условий:
```
z, nz, c, nc, s, ns, o, no - тестирует соответствующий флаг (n* для 'НЕ')
a  - беззнаковое 'above' (больше)
be - беззнаковое 'below or equal' (ниже или равно)
ge - знаковое 'greater or equal' (больше или равно)
l  - знаковое 'less' (меньше)
g  - знаковое 'greater' (больше)
le - знаковое 'less or equal' (меньше или равно)
```
Последние шесть условий по классике подразумевают, что только что была выполнена операция вычитания аргументов и вопрос стоит как 'Y по отношению к X?'.
4. CALL (вызов процедур/подпрограмм) не может в Simpleton быть реализован в одну инструкцию и реализуется в две:
```
addis [ sp ] pc 2 		; вычислим адрес возврата и поместим его в вершину стека
move pc proc_address		; переходим на адрес процедуры
```
Существует ассемблерная мнемоника реализующая эти две инструкции в одну строку:
```
call proc_address
```
Получается, что call в Simpleton состоит из двух инструкций и занимает минимум три слова. По моему это наиболее значимое пенальти в этой минималистичной системе команд.
5. Однако ret (возврат из процедуры) это одно слово инструкции извлечения из вершины стека pc:
```
move pc [ sp ]		; есть псевдоинструкция 'ret'
```
6. addi где X=0 можно записать псевдоинструкцией movet (тестирующий move):
```
StrCpy: 		; R1 - указатель на src, R2 - указатель на dst
  movet [ r2 ] [ r1 ] 	; movet то же самое что addi x y 0
  jz Exit
  addis r1 r1 1		; увеличиваем r1
  addis r2 r2 1		; увеличиваем r2
  move pc StrCpy
Exit:
  ret 			; псевдоним для move pc [ sp ]
```
7. Включение/выключение прерываний не требует специальных инструкций как во многих других процессорах, а делается через логические инструкции:
```
and psw psw flag_mask ; включить
or psw psw inv_flag_mask ; отключить
```
Тут важно заметить, что АЛУ сперва обновляет регистр флагов и только потом записывает результат в R. Таким образом если psw указан как R, то обновление флагов произошедшее во время операции просто затирается.
8.  Ключевое слово 'void' на месте R означает запись в [ pc ] - то есть отмену записи. Обновление флагов, однако, происходит, что может быть использовано чтобы реализовать типичную для других процессоров инструкцию cmp (неразрушающее регистры сравнение):
```                                              
sub void A B ; действует как 'cmp A B' во многих других ISA
jnz ...
```
...или тестирование бит любого рода:
```
and void r0 $0001
jz ...
```
...или проверка i-ого бита операнда помещением его во флаг переноса (инструкция rrci):
```
rrci void r0 3 ; CF получит бит 3
jc ... ; переход если CF=1
```

### Новый синтаксис ассемблера

В ассемблере есть ключевое слово 'mode classic' и 'mode new' которые переключают его в классическую и "математическую" нотации.
Большинство инструкций в "математической" нотации может быть написано как 'R = Y op X' где 'op' это "знак операции".
Следующие инструкции попападают под это правило (пример для R=R0, Y=R1 и X=[ label ]):
```
04 - ADDS : r0 = r1 +s [ label ] ; сложение без флагов
05 - ADD  : r0 = r1 +  [ label ] ; сложение
06 - ADC  : r0 = r1 +c [ lavel ] ; сложение с переносом
07 - SUB  : r0 = r1 -  [ label ] ; вычитание
08 - SBC  : r0 = r1 -c [ label ] ; вычитание с переносом
09 - AND  : r0 = r1 &  [ label ] ; and
0A - OR   : r0 = r1 |  [ label ] ; or
0B - XOR  : r0 = r1 ^  [ label ] ; xor
0C - CADD : r0 = r1 +? [ label ] ; условное сложение
0D - RRC  : r0 = r1 >> [ label ] ; прокрутка Y направо (циклическая) на X бит
```
Но три опкода с inplace immediate выпадают из этого правила и имеют особый синтаксис:
```
00 - ADDIS : r0 <- r1 - 1         ; сложение с inplace immediate без флагов
01 - ADDI  : r0 <= r1 + 3         ; сложение с inplace immediate
02 - RRCI  : r0 <= r1 >> 15       ; прокрутка направо (циклическая) на inplace immediate бит
```
Из эти инструкций те, что обновляют флаги используют '<=' вместо знака равенства.
И исключение из исключений - это 'addis' которая использует вместо знака равенства '<-' чтобы обозначить, что инструкция не обновляет флаги.
Если X в '<-' опущен, тогда он подразумевается равным нулю и запись 'r0 <- r1' есть более краткий вариант для 'move' и псевдоним для 'r0 <- r1 + 0'.
Нужно отметить, что 'addis a b -1' (отрицательный аргумент) может быть выражен и как 'a <- b + -1', но так же и как 'a <- b - 1'. Ассемблер распознаёт такое - главное чтобы аргумент был в пределах -8..+7.

Все псевдоинструкции ассемблера предназначенные для облегчения программирования (call/ret/jnz и т.п.) продолжают работать без изменений и в новом синтаксисе.
